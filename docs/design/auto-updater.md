# Auto-Updater Design Document

## Overview

This document outlines the design for implementing automatic updates in localmost, a macOS Electron app for running GitHub Actions locally.

## Goals

1. **Seamless updates** - Users should be able to update with minimal friction
2. **Security** - Updates must be cryptographically verified before installation
3. **User control** - Users can choose when to install updates
4. **Reliability** - Update failures should not break the app
5. **Transparency** - Clear communication about what's being updated

## Non-Goals

- Windows/Linux support (macOS only per CLAUDE.md)
- Delta updates (full app replacement is acceptable for MVP)
- Auto-restart without user consent

---

## Architecture

### Technology Choice: `electron-updater`

We'll use `electron-updater` from the electron-builder ecosystem because:

- **Native macOS support** - Works with code-signed DMG/ZIP releases
- **GitHub Releases integration** - Natural fit since we host on GitHub
- **Signature verification** - Built-in support for code signing verification
- **Mature ecosystem** - Well-tested, widely used
- **Staging support** - Can test updates before wide rollout

### Update Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                        Update Lifecycle                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. CHECK          2. DOWNLOAD        3. VERIFY        4. INSTALL│
│  ┌──────────┐     ┌──────────┐      ┌──────────┐     ┌──────────┐│
│  │ Query    │────▶│ Download │─────▶│ Validate │────▶│ Prompt   ││
│  │ GitHub   │     │ Update   │      │ Signature│     │ User &   ││
│  │ Releases │     │ ZIP      │      │          │     │ Restart  ││
│  └──────────┘     └──────────┘      └──────────┘     └──────────┘│
│       │                │                  │               │      │
│       ▼                ▼                  ▼               ▼      │
│  ┌──────────┐     ┌──────────┐      ┌──────────┐     ┌──────────┐│
│  │ No Update│     │ Progress │      │ Reject   │     │ Apply &  ││
│  │ Available│     │ Events   │      │ Invalid  │     │ Relaunch ││
│  └──────────┘     └──────────┘      └──────────┘     └──────────┘│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Component Overview

```
src/main/
├── auto-updater.ts          # Core update logic
├── ipc-handlers/
│   └── updater.ts           # IPC handlers for update operations
└── ...

src/renderer/
├── components/
│   ├── UpdateNotification.tsx   # Toast/banner for available updates
│   └── SettingsPage.tsx         # Update preferences (existing)
├── contexts/
│   └── UpdateContext.tsx        # Update state management
└── ...

src/shared/
└── types.ts                 # Update-related types
```

---

## Detailed Design

### 1. Update Configuration

**GitHub Releases as Update Source**

Updates will be distributed via GitHub Releases with the following structure:

```
Release: v0.2.0
├── localmost-0.2.0-arm64.dmg
├── localmost-0.2.0-arm64.dmg.blockmap
├── localmost-0.2.0-arm64-mac.zip
├── localmost-0.2.0-arm64-mac.zip.blockmap
├── latest-mac.yml              # Update manifest
└── release-notes.md
```

**latest-mac.yml format** (auto-generated by electron-builder):
```yaml
version: 0.2.0
files:
  - url: localmost-0.2.0-arm64-mac.zip
    sha512: <hash>
    size: 12345678
path: localmost-0.2.0-arm64-mac.zip
sha512: <hash>
releaseDate: '2024-01-15T10:00:00.000Z'
```

### 2. Main Process Module

**`src/main/auto-updater.ts`**

```typescript
import { autoUpdater, UpdateInfo, ProgressInfo } from 'electron-updater';
import { BrowserWindow } from 'electron';
import log from 'electron-log';

export interface UpdateState {
  status: 'idle' | 'checking' | 'available' | 'downloading' | 'downloaded' | 'error';
  currentVersion: string;
  availableVersion?: string;
  releaseNotes?: string;
  downloadProgress?: number;
  error?: string;
}

export function initAutoUpdater(mainWindow: BrowserWindow): void {
  // Configure logging
  autoUpdater.logger = log;

  // GitHub releases URL (auto-detected from package.json repository field)
  autoUpdater.setFeedURL({
    provider: 'github',
    owner: 'bfulton',
    repo: 'localmost',
  });

  // Disable auto-download - let user decide
  autoUpdater.autoDownload = false;
  autoUpdater.autoInstallOnAppQuit = true;

  // Event handlers
  autoUpdater.on('checking-for-update', () => {
    sendUpdateStatus(mainWindow, { status: 'checking' });
  });

  autoUpdater.on('update-available', (info: UpdateInfo) => {
    sendUpdateStatus(mainWindow, {
      status: 'available',
      availableVersion: info.version,
      releaseNotes: formatReleaseNotes(info.releaseNotes),
    });
  });

  autoUpdater.on('update-not-available', () => {
    sendUpdateStatus(mainWindow, { status: 'idle' });
  });

  autoUpdater.on('download-progress', (progress: ProgressInfo) => {
    sendUpdateStatus(mainWindow, {
      status: 'downloading',
      downloadProgress: progress.percent,
    });
  });

  autoUpdater.on('update-downloaded', (info: UpdateInfo) => {
    sendUpdateStatus(mainWindow, {
      status: 'downloaded',
      availableVersion: info.version,
    });
  });

  autoUpdater.on('error', (error: Error) => {
    sendUpdateStatus(mainWindow, {
      status: 'error',
      error: error.message,
    });
  });
}

export async function checkForUpdates(): Promise<void> {
  await autoUpdater.checkForUpdates();
}

export async function downloadUpdate(): Promise<void> {
  await autoUpdater.downloadUpdate();
}

export function installUpdate(): void {
  // Quit and install - will relaunch app
  autoUpdater.quitAndInstall(false, true);
}
```

### 3. IPC Channels

**New channels in `src/shared/types.ts`:**

```typescript
export const IpcChannels = {
  // ... existing channels ...

  // Update channels
  UPDATE_CHECK: 'update:check',
  UPDATE_DOWNLOAD: 'update:download',
  UPDATE_INSTALL: 'update:install',
  UPDATE_STATUS: 'update:status',
  UPDATE_GET_SETTINGS: 'update:get-settings',
  UPDATE_SET_SETTINGS: 'update:set-settings',
} as const;

export interface UpdateSettings {
  autoCheck: boolean;           // Check on startup (default: true)
  checkInterval: number;        // Hours between checks (default: 24)
  notifyOnly: boolean;          // Only notify, don't auto-download (default: true)
}
```

**IPC Handlers in `src/main/ipc-handlers/updater.ts`:**

```typescript
import { ipcMain } from 'electron';
import { IpcChannels, UpdateSettings } from '../../shared/types';
import { checkForUpdates, downloadUpdate, installUpdate } from '../auto-updater';
import { getConfig, saveConfig } from '../config';

export function registerUpdateHandlers(): void {
  ipcMain.handle(IpcChannels.UPDATE_CHECK, async () => {
    await checkForUpdates();
  });

  ipcMain.handle(IpcChannels.UPDATE_DOWNLOAD, async () => {
    await downloadUpdate();
  });

  ipcMain.handle(IpcChannels.UPDATE_INSTALL, () => {
    installUpdate();
  });

  ipcMain.handle(IpcChannels.UPDATE_GET_SETTINGS, async () => {
    const config = await getConfig();
    return config.updateSettings ?? defaultUpdateSettings;
  });

  ipcMain.handle(IpcChannels.UPDATE_SET_SETTINGS, async (_, settings: UpdateSettings) => {
    const config = await getConfig();
    config.updateSettings = settings;
    await saveConfig(config);
  });
}
```

### 4. Preload API

**Additions to `src/main/preload.ts`:**

```typescript
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing API ...

  // Update API
  checkForUpdates: () => ipcRenderer.invoke(IpcChannels.UPDATE_CHECK),
  downloadUpdate: () => ipcRenderer.invoke(IpcChannels.UPDATE_DOWNLOAD),
  installUpdate: () => ipcRenderer.invoke(IpcChannels.UPDATE_INSTALL),
  onUpdateStatus: (callback: (status: UpdateState) => void) => {
    const handler = (_: IpcRendererEvent, status: UpdateState) => callback(status);
    ipcRenderer.on(IpcChannels.UPDATE_STATUS, handler);
    return () => ipcRenderer.removeListener(IpcChannels.UPDATE_STATUS, handler);
  },
  getUpdateSettings: () => ipcRenderer.invoke(IpcChannels.UPDATE_GET_SETTINGS),
  setUpdateSettings: (settings: UpdateSettings) =>
    ipcRenderer.invoke(IpcChannels.UPDATE_SET_SETTINGS, settings),
});
```

### 5. Renderer Components

**Update Notification Banner (`src/renderer/components/UpdateNotification.tsx`):**

```tsx
import React from 'react';
import { useUpdate } from '../contexts/UpdateContext';

export const UpdateNotification: React.FC = () => {
  const { state, downloadUpdate, installUpdate, dismissUpdate } = useUpdate();

  if (state.status === 'idle' || state.status === 'checking') {
    return null;
  }

  if (state.status === 'available') {
    return (
      <div className="update-banner update-available">
        <span>Version {state.availableVersion} is available</span>
        <button onClick={downloadUpdate}>Download</button>
        <button onClick={dismissUpdate}>Later</button>
      </div>
    );
  }

  if (state.status === 'downloading') {
    return (
      <div className="update-banner update-downloading">
        <span>Downloading update... {state.downloadProgress?.toFixed(0)}%</span>
        <progress value={state.downloadProgress} max={100} />
      </div>
    );
  }

  if (state.status === 'downloaded') {
    return (
      <div className="update-banner update-ready">
        <span>Update ready to install</span>
        <button onClick={installUpdate}>Restart & Install</button>
        <button onClick={dismissUpdate}>Later</button>
      </div>
    );
  }

  if (state.status === 'error') {
    return (
      <div className="update-banner update-error">
        <span>Update failed: {state.error}</span>
        <button onClick={dismissUpdate}>Dismiss</button>
      </div>
    );
  }

  return null;
};
```

**Settings Integration (`src/renderer/components/SettingsPage.tsx`):**

Add update settings section:

```tsx
// In SettingsPage.tsx
<section className="settings-section">
  <h3>Updates</h3>
  <div className="setting-row">
    <label>
      <input
        type="checkbox"
        checked={updateSettings.autoCheck}
        onChange={(e) => setUpdateSettings({
          ...updateSettings,
          autoCheck: e.target.checked
        })}
      />
      Check for updates automatically
    </label>
  </div>
  <div className="setting-row">
    <button onClick={checkForUpdates} disabled={isChecking}>
      {isChecking ? 'Checking...' : 'Check for Updates Now'}
    </button>
    <span className="version-info">Current version: {currentVersion}</span>
  </div>
</section>
```

### 6. Update Check Schedule

**Automatic checking on app startup and periodically:**

```typescript
// In src/main/index.ts, after app ready

import { initAutoUpdater, checkForUpdates } from './auto-updater';

app.whenReady().then(async () => {
  // ... existing initialization ...

  const mainWindow = createWindow();
  initAutoUpdater(mainWindow);

  // Check for updates on startup (if enabled)
  const config = await getConfig();
  if (config.updateSettings?.autoCheck !== false) {
    // Delay initial check to not slow down startup
    setTimeout(() => checkForUpdates(), 10000);
  }

  // Periodic check (default: every 24 hours)
  const checkInterval = (config.updateSettings?.checkInterval ?? 24) * 60 * 60 * 1000;
  setInterval(() => {
    if (config.updateSettings?.autoCheck !== false) {
      checkForUpdates();
    }
  }, checkInterval);
});
```

---

## Build Configuration Changes

### forge.config.js Updates

```javascript
module.exports = {
  // ... existing config ...

  packagerConfig: {
    // ... existing options ...

    // Required for auto-updater
    osxSign: {
      identity: process.env.APPLE_IDENTITY,
      hardenedRuntime: true,
      entitlements: 'entitlements.plist',
      'entitlements-inherit': 'entitlements.plist',
    },
    osxNotarize: {
      tool: 'notarytool',
      appleId: process.env.APPLE_ID,
      appleIdPassword: process.env.APPLE_PASSWORD,
      teamId: process.env.APPLE_TEAM_ID,
    },
  },

  makers: [
    {
      name: '@electron-forge/maker-zip',
      platforms: ['darwin'],
      config: {},
    },
    {
      name: '@electron-forge/maker-dmg',
      config: {
        format: 'ULFO',
      },
    },
  ],

  publishers: [
    {
      name: '@electron-forge/publisher-github',
      config: {
        repository: {
          owner: 'bfulton',
          name: 'localmost',
        },
        prerelease: false,
        draft: true, // Create as draft, publish manually after testing
      },
    },
  ],
};
```

### package.json Updates

```json
{
  "build": {
    "appId": "com.localmost.app",
    "productName": "localmost",
    "mac": {
      "category": "public.app-category.developer-tools",
      "target": ["dmg", "zip"],
      "hardenedRuntime": true,
      "gatekeeperAssess": false,
      "entitlements": "entitlements.plist",
      "entitlementsInherit": "entitlements.plist"
    },
    "publish": {
      "provider": "github",
      "owner": "bfulton",
      "repo": "localmost"
    }
  }
}
```

---

## Security Considerations

### 1. Code Signature Verification

- electron-updater automatically verifies that updates are signed with the same certificate as the running app
- Updates from unsigned or differently-signed sources will be rejected
- This prevents MITM attacks on the update channel

### 2. HTTPS Only

- GitHub Releases uses HTTPS by default
- electron-updater rejects HTTP update sources

### 3. Checksum Verification

- SHA-512 checksums in latest-mac.yml are verified before installation
- Corrupted downloads are rejected

### 4. User Consent

- Auto-download is disabled by default
- Users must explicitly choose to download and install updates
- Clear UI indication of what version is being installed

### 5. Rollback Capability

For MVP, rollback would be manual (download previous version from GitHub Releases). Future enhancement could include:
- Keeping previous version in a backup location
- Automatic rollback if new version crashes on startup

---

## User Experience

### Update States & UI

| State | Icon | Banner Color | Actions |
|-------|------|--------------|---------|
| Checking | Spinner | None | - |
| Available | ⬆️ | Blue | Download, Later |
| Downloading | Progress | Blue | - |
| Downloaded | ✓ | Green | Install, Later |
| Error | ⚠️ | Red | Retry, Dismiss |

### Notification Behavior

1. **Non-intrusive** - Banner at top of window, doesn't block usage
2. **Persistent** - Available update banner stays until actioned
3. **Dismissible** - User can dismiss and be reminded next session
4. **Progress visible** - Download progress clearly shown

### Settings Options

- **Auto-check for updates** (default: ON)
- **Check interval** (default: 24 hours, options: 6h, 12h, 24h, weekly)
- **"Check Now" button** - Manual check with immediate feedback

---

## Testing Strategy

### Unit Tests

- Mock electron-updater events
- Test state transitions
- Test IPC handlers

### Integration Tests

- Test with local update server (electron-updater supports custom feed URLs)
- Verify signature validation rejects unsigned updates
- Test download interruption/resume

### Manual Testing

- Create test releases on GitHub (drafts)
- Verify full update flow on clean install
- Test with different network conditions

### Staged Rollout

1. Release as draft on GitHub
2. Internal testing with draft release
3. Publish to GitHub Releases
4. Monitor crash reports/feedback

---

## Implementation Plan

### Phase 1: Core Infrastructure
1. Add electron-updater dependency
2. Create auto-updater.ts module
3. Add IPC handlers for update operations
4. Update preload.ts with update API

### Phase 2: UI Integration
5. Create UpdateContext for state management
6. Build UpdateNotification component
7. Add update settings to SettingsPage
8. Style update banners

### Phase 3: Build Pipeline
9. Update forge.config.js for publishing
10. Add GitHub publisher configuration
11. Update CI workflow to create releases

### Phase 4: Testing & Polish
12. Add unit tests for update logic
13. Manual testing with draft releases
14. Documentation updates
15. Release

---

## Open Questions

1. **Pre-release channel?** - Should we support beta updates for early adopters?
   - Recommendation: Not for MVP, add later if there's demand

2. **Update size display?** - Show download size before downloading?
   - Recommendation: Yes, include in available update notification

3. **Background downloads?** - Download while user works, prompt when ready?
   - Recommendation: Yes, this is the current design (autoInstallOnAppQuit)

4. **Release notes display?** - Show changelog in update notification?
   - Recommendation: Brief summary in notification, full notes via "View Details" link

---

## Alternatives Considered

### 1. Sparkle Framework
- **Pros:** Native macOS, mature, widely used
- **Cons:** Requires native code integration, more complex setup
- **Decision:** electron-updater is simpler and sufficient

### 2. Custom Update Server
- **Pros:** Full control, custom logic
- **Cons:** Infrastructure to maintain, reinventing the wheel
- **Decision:** GitHub Releases is free, reliable, and integrated

### 3. Mac App Store Distribution
- **Pros:** Automatic updates via MAS
- **Cons:** Review process, revenue share, sandboxing limitations
- **Decision:** Not suitable for this app's functionality

---

## Appendix: Dependencies to Add

```bash
npm install electron-updater
npm install --save-dev @electron-forge/publisher-github
```

## Appendix: File Changes Summary

| File | Change |
|------|--------|
| package.json | Add dependencies, build config |
| forge.config.js | Add publisher config |
| src/main/auto-updater.ts | New file - core update logic |
| src/main/ipc-handlers/updater.ts | New file - IPC handlers |
| src/main/ipc-handlers/index.ts | Register update handlers |
| src/main/index.ts | Initialize auto-updater |
| src/main/preload.ts | Add update API |
| src/shared/types.ts | Add update types |
| src/renderer/contexts/UpdateContext.tsx | New file - update state |
| src/renderer/components/UpdateNotification.tsx | New file - UI |
| src/renderer/components/SettingsPage.tsx | Add update settings |
| src/renderer/styles/update.module.css | New file - styles |
